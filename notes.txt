There is a special variable named 'input' that holds an integer
that is the input to the program.

--------------------------------------------------------------------------------
Integers, expressions, and variables

e ::= n | x | (+ e e) | (- e) | (let: ([x : Integer e] ...) e)

--------------------------------------------------------------------------------
Register Allocation

--------------------------------------------------------------------------------
Vectors and type checking

T ::= Integer | (Vectorof T)
e ::= ...
    | (vector-immutable e ...) | (vector-length e) | (vector-ref e e)
--------------------------------------------------------------------------------
Conditional control flow and Booleans

T ::= Integer | Boolean | (Vectorof T)
e ::= ...
    | #t | #f | (if e e e) | (equal? e e) | (and e e) | (or e e) | (not e)

--------------------------------------------------------------------------------
Functions

p ::= (program d ... e)
d ::= (define (f [x : T] ...) e)
e ::= ...
    | (f e ...)

--------------------------------------------------------------------------------
Garbage Collection



--------------------------------------------------------------------------------
First-Class Functions

T ::= Integer | Boolean | (Vectorof T) | (T ... -> T)
e ::= ...
    | (lambda: ([x : T] ...) e) 
    | (e e ...)

--------------------------------------------------------------------------------
Type dynamic

T ::= Integer | Boolean | (Vectorof T) | (-> T T ...) | Dyn
G ::= Integer | Boolean | (Vectorof Dyn) | (-> Dyn Dyn ...)
e ::= n | x | (+ e e) | (- e) | (let: ([x : T e] ...) e)
    | (vector-immutable e ...) | (vector-length e) | (vector-ref e e)
    | #t | #f | (if e e e) | (equal? e e) | (and e e) | (or e e) | (not e)
    | (lambda: ([x : T] ...) e) | (e e ...)
    | (inject e G) | (project e G) | (isa? G e)

--------------------------------------------------------------------------------
Dynamic typing
(side project)

e ::= n | x | (+ e e) | (- e) | (let ([x e] ...) e)
    | (vector-immutable e ...) | (vector-length e) | (vector-ref e e)
    | #t | #f | (if e e e) | (equal? e e) | (and e e) | (or e e) | (not e)
    | (lambda (x ...) e) | (e e ...)

--------------------------------------------------------------------------------
Gradual typing

T ::= Integer | Boolean | (Vectorof T) | (-> T T ...) | Dyn
e ::= n | x | (+ e e) | (- e) | (let: ([x : T e] ...) e)
    | (vector-immutable e ...) | (vector-length e) | (vector-ref e e)
    | #t | #f | (if e e e) | (equal? e e) | (and e e) | (or e e) | (not e)
    | (lambda: ([x : T] ...) e) | (e e ...)
    | (lambda (x ...) e) | (let ([x e] ...) e)
    | (ann e T) | (static e) | (dynamic e)

--------------------------------------------------------------------------------
Lists and mutation

T ::= Integer | Boolean | (Vectorof T) | (-> T T ...) | Dyn | (Listof T)
e ::= ...
    | (eq? e e)
    | null | (mcons e e) | (mcar e) | (mcdr e) | (set-mcar! e e) |
      (set-mcdr! e e)

--------------------------------------------------------------------------------
Parametric Polymorphism


--------------------------------------------------------------------------------
Optimization (Function inlining, constant folding, etc.)


--------------------------------------------------------------------------------
Integers, expressions, and variables (int_exp.rkt)  [249 lines]

Language S_0:
e ::= n | x | (+ e e) | (- e e) | (- e) | (read) | (let ([x e]) e)

  * uniquify
  * flatten to C0
    atomic   a  ::= n | x
    expr     e  ::= a | (prim op a ...)
    stmt     s  ::= (assign x e) | (return a)
    program  p  ::= (program (x ...) (s ...))
  * instruction selection to x86

--------------------------------------------------------------------------------
Parsing? Racket has "Parser Tools: lex and yacc-style Parsing"
  and there's an example of doing S_0 by Dan King
  https://gist.github.com/danking/1068185

--------------------------------------------------------------------------------
Register Allocation (register_allocator.rkt) [210 lines]

reserve rax for spill code
 -> can use same code as prior to register allocation!

perform a single-pass of register allocation

--------------------------------------------------------------------------------
Conditional control flow, Booleans, and type checking (conditionals.rkt)
  [311 lines]

S1

T ::= Integer | Boolean
e ::= ...
    | #t | #f | (if e e e) | (eq? e e) | (and e e) | (or e e) | (not e)


|- e0 : T      |- e1 : T
------------------------
|- (eq? e0 e1) : Bool


--------------------------------------------------------------------------------
Tuples (Racket Vectors) and heap allocation (vectors.rkt)
  [136 lines] (too easy?)

(needed to represent closures)

T ::= Integer | (Vector T_1 ... T_n) | Void
e ::= ...
    | (vector e_1 ... e_n) | (vector-ref e e)
    | (vector-set! e e e)

Type System

|- e0 : Integer      |- e1 : T
-------------------------------------
|- (vector e_1 ... e_n) : (Vector T1 ... Tn)

|- e : (Vector T_1 ... T_n)
---------------------------
|- (vector-ref e i) : T_i

|- e_1 : (Vector T_1 ... T_n)   |- e_2 : T_i
--------------------------------------------
|- (vector-set! e_1 i e_2) : Void

--------------------------------------------------------------------------------
Functions (functions.rkt) (second-class)

p ::= (program d ... e)
d ::= (define (f [x : T] ...) : T e)
e ::= ...
    | (f e ...)

--------------------------------------------------------------------------------
Garbage Collection (Copying Collector)

idea:
  * Put pointers (GC roots) on a separate stack to differentiate from non-pointers.
  * We still need to have type information about the objects on the heap to facilitate
    recursively exploring them during collection.
    - Create a table for type information, with a unique natural number for each type,
      assigned during compilation.
      Allocate the table during initialization of the program.
  

--------------------------------------------------------------------------------
First-Class Functions

T ::= Integer | Boolean | (Vectorof T) | (T ... -> T)
e ::= ...
    | (lambda: ([x : T] ...) e) 
    | (e e ...)

--------------------------------------------------------------------------------
Type dynamic

T ::= Integer | Boolean | (Vectorof T) | (-> T T ...) | Dyn
G ::= Integer | Boolean | Vector | Function
e ::= ...
    | (inject e G) | (project e G) | (isa? G e)

--------------------------------------------------------------------------------
Dynamic typing
(side project)

e ::= n | x | (+ e e) | (- e) | (let ([x e] ...) e)
    | (vector-immutable e ...) | (vector-length e) | (vector-ref e e)
    | #t | #f | (if e e e) | (equal? e e) | (and e e) | (or e e) | (not e)
    | (lambda (x ...) e) | (e e ...)

--------------------------------------------------------------------------------
Gradual typing

T ::= Integer | Boolean | (Vectorof T) | (-> T T ...) | Dyn
e ::= n | x | (+ e e) | (- e) | (let: ([x : T e] ...) e)
    | (vector-immutable e ...) | (vector-length e) | (vector-ref e e)
    | #t | #f | (if e e e) | (equal? e e) | (and e e) | (or e e) | (not e)
    | (lambda: ([x : T] ...) e) | (e e ...)
    | (lambda (x ...) e) | (let ([x e] ...) e)
    | (ann e T) | (static e) | (dynamic e)

--------------------------------------------------------------------------------
Lists and mutation

T ::= Integer | Boolean | (Vectorof T) | (-> T T ...) | Dyn | (Listof T)
e ::= ...
    | (eq? e e)
    | null | (mcons e e) | (mcar e) | (mcdr e) | (set-mcar! e e) |
      (set-mcdr! e e)

--------------------------------------------------------------------------------
Parametric Polymorphism (strech goal)


--------------------------------------------------------------------------------
Optimization (Function inlining, constant folding, etc.)


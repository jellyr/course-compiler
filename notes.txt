--------------------------------------------------------------------------------
Integers, expressions, and variables
Language S_0:
e ::= n | x | (+ e e) | (- e e) | (- e) | (read) | (let ([x e]) e)

  * uniquify
  * flatten to C0
    atomic   a  ::= n | x
    expr     e  ::= a | (prim op a ...)
    stmt     s  ::= (assign x e) | (return a)
    program  p  ::= (program (x ...) (s ...))
  * instruction selection to x86

--------------------------------------------------------------------------------
Parsing? Racket has "Parser Tools: lex and yacc-style Parsing"
  and there's an example of doing S_0 by Dan King
  https://gist.github.com/danking/1068185

--------------------------------------------------------------------------------
Register Allocation

reserve rax for spill code
 -> can use same code as prior to register allocation!

perform a single-pass of register allocation

--------------------------------------------------------------------------------
Vectors and type checking

T ::= Integer | (Vectorof T)
e ::= ...
    | (vector-immutable e ...) | (vector-length e) | (vector-ref e e)
--------------------------------------------------------------------------------
Conditional control flow and Booleans

T ::= Integer | Boolean | (Vectorof T)
e ::= ...
    | #t | #f | (if e e e) | (equal? e e) | (and e e) | (or e e) | (not e)

--------------------------------------------------------------------------------
Functions

p ::= (program d ... e)
d ::= (define (f [x : T] ...) e)
e ::= ...
    | (f e ...)

--------------------------------------------------------------------------------
Garbage Collection



--------------------------------------------------------------------------------
First-Class Functions

T ::= Integer | Boolean | (Vectorof T) | (T ... -> T)
e ::= ...
    | (lambda: ([x : T] ...) e) 
    | (e e ...)

--------------------------------------------------------------------------------
Type dynamic

T ::= Integer | Boolean | (Vectorof T) | (-> T T ...) | Dyn
G ::= Integer | Boolean | Vector | Function
e ::= ...
    | (inject e G) | (project e G) | (isa? G e)

--------------------------------------------------------------------------------
Dynamic typing
(side project)

e ::= n | x | (+ e e) | (- e) | (let ([x e] ...) e)
    | (vector-immutable e ...) | (vector-length e) | (vector-ref e e)
    | #t | #f | (if e e e) | (equal? e e) | (and e e) | (or e e) | (not e)
    | (lambda (x ...) e) | (e e ...)

--------------------------------------------------------------------------------
Gradual typing

T ::= Integer | Boolean | (Vectorof T) | (-> T T ...) | Dyn
e ::= n | x | (+ e e) | (- e) | (let: ([x : T e] ...) e)
    | (vector-immutable e ...) | (vector-length e) | (vector-ref e e)
    | #t | #f | (if e e e) | (equal? e e) | (and e e) | (or e e) | (not e)
    | (lambda: ([x : T] ...) e) | (e e ...)
    | (lambda (x ...) e) | (let ([x e] ...) e)
    | (ann e T) | (static e) | (dynamic e)

--------------------------------------------------------------------------------
Lists and mutation

T ::= Integer | Boolean | (Vectorof T) | (-> T T ...) | Dyn | (Listof T)
e ::= ...
    | (eq? e e)
    | null | (mcons e e) | (mcar e) | (mcdr e) | (set-mcar! e e) |
      (set-mcdr! e e)

--------------------------------------------------------------------------------
Parametric Polymorphism


--------------------------------------------------------------------------------
Optimization (Function inlining, constant folding, etc.)

